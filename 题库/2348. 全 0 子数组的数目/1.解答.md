# 前言

本题做法很多，下面讲两个更具一般性的方法。



---

# 方法一：用滑动窗口思考

## 题解

子数组越长，越可能包含非零元素，不满足题目要求；子数组越短，越可能全为 0，满足题目要求。我们枚举子数组的右端点，当右端点变大（子数组变长）的时候，子数组左端点要么不变，要么也变大。

不仅是本题，有这样性质的题目，都可以用滑动窗口解决。

本题属于「越短越合法」型滑动窗口。

~~~java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long ans = 0;
        int left = 0;
        int noZeroCount = 0;
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                noZeroCount++;
            }
            while (noZeroCount > 0) {
                if (nums[left] != 0) {
                    noZeroCount--;
                }
                left++;
            }
            ans += (right - left + 1);
        }
        return ans;
    }
}
~~~

由于题目的特殊性，有更简单的解决方法：

记录上一个非零数字的位置 $last$。那么 $last+1$ 就是窗口的左端点。
当子数组右端点在 $i$ 时，子数组左端点可以是 $last+1,last+2,…,i$，一共有 $i−last$ 个，加入答案。
示例 1 的 $nums=[1,3,0,0,2,0,0,4]$，当右端点在 $i=3$ 时，$last=1$，我们找到了 $i−last=2$ 个右端点在 $3$ 的全 0 子数组，加入答案。

为了兼容 $nums=[0,0,0,2,0,0]$ 这种一开始就是 0 的情况，初始化 $last=−1$。

~~~java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long ans = 0;
        int last = -1;
        for (int i = 0; i < nums.length; i++) {
            int x = nums[i];
            if (x != 0) {
                last = i; // 记录上一个非 0 元素的位置
            } else {
                ans += i - last;
            }
        }
        return ans;
    }
}
~~~

---

## 复杂度分析

时间复杂度：$O(n)$，其中 $n$ 是 $nums$ 的长度。
空间复杂度：$O(1)$。



---

# 方法二：增量法

## 题解

遍历到 $nums[i] \not= 0$，现在来计算右端点为 i 的全 0 子数组的个数。

我们可以在右端点为 $i−1$ 的全 $0$ 子数组的末尾添加一个 $0$。比如右端点为 $i−1$ 的全 $0 子$数组有 $5$ 个，那么在这 $5$ 个子数组的末尾添加 $nums[i]=0$，再算上 $nums[i]$ 单独组成一个长为 1 的子数组，我们得到了 $5+1=6$ 个右端点为 $i$ 的全 0 子数组，加入答案。

具体来说：

用一个计数器 $cnt0$

1. 统计遍历到的连续 0 的个数。
2. 如果 $nums[i] \neq 0$，把计数器重置为 $0。$
   否则，把 $cnt0$ 加一，表示右端点为 $i$ 的全 0 子数组比右端点为 $i−1$ 的全 0 子数组多一个。然后把 $cnt0$ 加到答案中。

~~~java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long ans = 0;
        int cnt0 = 0;
        for (int x : nums) {
            if (x != 0) {
                cnt0 = 0;
            } else {
                cnt0++; // 右端点为 i 的全 0 子数组比右端点为 i-1 的全 0 子数组多一个
                ans += cnt0;
            }
        }
        return ans;
    }
}
~~~

---

## 复杂度分析

- 时间复杂度：$O(n)$，其中 $n$ 是 $nums$ 的长度。
- 空间复杂度：$O(1)$。

注：本题还有其他方法，例如找极大连续 0 的长度，然后用等差数列计算。

# 相似题目

`413.等差数列划分`



---

# 专题训练

方法一：滑动窗口题单的「**§2.3.1 越短越合法**」。

方法二：动态规划题单「**§7.3 子数组 DP**」的「**思维扩展**」。

