# 我自己一开始的写法

~~~java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        int ans = 0;
        int left = 0;
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                ans++;
            } else {
                while (left <= right) {
                    left++;
                    if (left != right) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }
}
~~~

发给AI，被AI狠狠的教训了一顿：

1. 核心逻辑完全错误

   你的代码试图在遇到 0 和非 0 时执行两种截然不同的计数逻辑，但这两种逻辑都不符合题目的要求。

   **a) 当 nums[right] == 0 时：**

   ~~~java
   if (nums[right] == 0) {
       ans++;
   }
   ~~~

   这行代码的含义是：每当遇到一个 0，就把总数加一。这**仅仅计算了长度为 1 的全 0 子数组（即 [0]）的数量**。

   例如，对于输入 [0, 0, 0]：

   - 当 right = 0，ans 变为 1。
   - 当 right = 1，ans 变为 2。
   - 当 right = 2，ans 变为 3。

   最终结果是 3。但正确答案应该是 [0] (3个), [0,0] (2个), [0,0,0] (1个)，总共 3 + 2 + 1 = 6 个。你的代码完全漏掉了长度大于 1 的全 0 子数组。

   **b) 当 nums[right] != 0 时：**

   ~~~java
   else {
       while (left <= right) {
           left++;
           if (left != right) {
               ans++;
           }
       }
   }
   ~~~

   这段逻辑更加令人困惑，并且完全与题目目标背道而驰。题目的要求是统计**全 0**子数组。当遇到一个非 0 的数字时，任何包含这个数字的子数组都不可能是全 0 的，所以我们**不应该**增加 ans 的值。而你的代码却在此时启动了一个循环来增加 ans，这在逻辑上是说不通的。

2. left 指针的角色混乱

   在正确的滑动窗口解法中，left 指针通常用来标记当前有效窗口（在这里是连续 0 序列）的**起始位置**。

   在你的代码中，left 指针只在遇到非 0 数字时才移动。这意味着它并没有正确地跟踪当前连续 0 的起点。当连续遇到多个 0 时，left 指针是静止的，这使得它无法帮助你计算出当前连续 0 序列的长度。

3. 潜在的整数溢出问题

   题目的约束是 $1 <= nums.length <= 10^5$。
   假设输入是一个包含 $10^5$ 个 0 的数组，那么全 0 子数组的总数将是 $1 + 2 + ... + 100000$，这个结果大约是 $5 * 10^9$。

   Java 中 int 类型的最大值大约是 $2.1 * 10^9$。因此，使用 `int ans = 0;` 会导致结果溢出，从而得到错误的答案。你应该使用 long 来存储结果。



---

# 正确的思路应该是怎样的？

我们应该回到问题的本质：**计算以每个位置为结尾的全 0 子数组有多少个。**

让我们以 [1, 3, 0, 0, 2, 0, 0, 4] 为例：

- `right = 0 (nums[0]=1)`: 以 1 结尾的全 0 子数组有 **0** 个。
- right = 1 (nums[1]=3): 以 3 结尾的全 0 子数组有 **0** 个。
- right = 2 (nums[2]=0): 连续 0 的长度为 1。以它结尾的全 0 子数组只有 [0]，共 **1** 个。
- right = 3 (nums[3]=0): 连续 0 的长度为 2 ([0,0])。以它结尾的全 0 子数组有 [0,0] 和 [0]，共 **2** 个。
- right = 4 (nums[4]=2): 以 2 结尾的全 0 子数组有 **0** 个。
- right = 5 (nums[5]=0): 连续 0 的长度为 1。以它结尾的全 0 子数组只有 [0]，共 **1** 个。
- right = 6 (nums[6]=0): 连续 0 的长度为 2 ([0,0])。以它结尾的全 0 子数组有 [0,0] 和 [0]，共 **2** 个。
- right = 7 (nums[7]=4): 以 4 结尾的全 0 子数组有 **0** 个。

把这些数量加起来：0 + 0 + 1 + 2 + 0 + 1 + 2 + 0 = 6。这就是正确答案。

你会发现，当 nums[right] 为 0 时，新增的子数组数量恰好是**当前连续 0 的长度**。

所以，正确的算法很简单：

1. 维护一个计数器 consecutiveZeros，记录当前连续 0 的个数。
2. 遍历数组：
   - 如果 nums[i] 是 0，则 consecutiveZeros 加一。
   - 如果 nums[i] 不是 0，则连续段被打破，consecutiveZeros 重置为 0。
   - 每次循环，都将当前的 consecutiveZeros 的值累加到总答案 ans 中。

```java
class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long ans = 0;
        long consecutiveZeros = 0; // 使用 long 防止累加过程中的中间值溢出虽然在此题不必要，但是好习惯

        for (int num : nums) {
            if (num == 0) {
                consecutiveZeros++;
            } else {
                consecutiveZeros = 0;
            }
            ans += consecutiveZeros;
        }
        return ans;
    }
}
```